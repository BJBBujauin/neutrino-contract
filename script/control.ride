{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
#
# Smart Contract for Price Oracles and Emergency Oracles of Neutrino Protocol
#

#-------------------Base functions----------------------
func getNumberByKey(key: String) = {
    match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByKey(key: String) = {
    match getString(this, key) {
            case a:String => a
            case _ => ""
    }
}
func getBoolByKey(key: String) = {
    match getBoolean(this, key) {
            case a:Boolean => a
            case _ => false
    }
}
func getNumberByAddressAndKey(address: Address, key: String) = {
    match getInteger(address, key) {
            case a:Int => a
            case _ => 0
    }
}
func getStringByAddressAndKey(address: Address, key: String) = {
     match getString(address, key) {
            case a:String => a
            case _ => ""
    }
}
func convertJsonArrayToList(jsonArray: String) = {
   jsonArray.split(",") #jsonArray.take(size(jsonArray)-1).drop(1).split(",")
}
#-------------------Constants----------------------------
let AutoEmergencyOracleAddress = "3P7ihFVxBNbHK237TNdPxT1xHEu8pHexXTr"
let MsgPrefix = "neutrino_control"
let BftCoefficientOracle = 3

#-------------------Keys---------------------------------
#------This contract----------
let OraclesKey = "oracles"

let PricesKey = "prices"
let DeficitKey = "deficit"
let IsBlockedKey = "is_blocked"
let IsBlockedCallerKey = "is_blocked_caller"
let IsBlockedReasonKey = "is_blocked_reason"
let ProvidingIndexKey = "providing_index"

func getBlackSwarmPriceKey(block: Int) = "black_swarm_price" + "_" + toString(block)
func getPricesHistoryKey(block: Int) = PricesKey + "_" + toString(block)
func getDeficitsHistoryKey(block: Int) = DeficitKey + "_" + toString(block)
func getHeightByProvidingIndexKey(index: Int) = ProvidingIndexKey + "_" + toString(index)
func getOracleProvidePriceKey(height: Int) = "price_" + toString(height)
func getOracleIpsKey(oracle: String) = "ips_" + oracle

#-------------------Global vars-------------------------
let prices = getStringByKey(PricesKey)
let providingIndex = getNumberByKey(ProvidingIndexKey)

let isBlocked = getBoolByKey(IsBlockedKey)
let isBlockedCaller = getBoolByKey(IsBlockedCallerKey)

let pubKeyOracles = getStringByKey(OraclesKey)
let pubKeyOraclesList = convertJsonArrayToList(pubKeyOracles)

#-------------------Get func----------------------------
func getOracleProvideHeight(owner: String, height: Int) = getNumberByAddressAndKey(addressFromStringValue(owner), getOracleProvidePriceKey(height))
func getPricesHistory(height: Int) = getNumberByKey(getPricesHistoryKey(height))
func getOracleIps(oracle: String) = getStringByKey(getOracleIpsKey(oracle))

#-------------------Other func--------------------------
func isOracle(address: String) = {
    isDefined(indexOf(pubKeyOracles, address))
}

func formattingPriceMsg(defecit: Int, prices: String, height: Int) = {
    MsgPrefix + "_" + toString(defecit) + "_" + prices + "_" + toString(height)
}
#-------------------Callable----------------------
# [called by price oracles]
# only price oracles can block smart contract untill another price oracle will unblock it
@Callable(i)
func callEmergencyShutdown(reason: String) = {
    let callerAddress = toString(i.caller)
    if (AutoEmergencyOracleAddress != callerAddress) 
        then throw("caller must be one an emergency oracle")
    else 
        WriteSet([
            DataEntry(IsBlockedKey, true),
            DataEntry(IsBlockedCallerKey, callerAddress),
            DataEntry(IsBlockedReasonKey, reason)
        ])
}
 
@Callable(i)
func setOracleIps(ips: String) = {
    let pubKeyString = toBase58String(i.callerPublicKey)
    if(isBlocked)
        then throw("contract is blocked")
    else if(!isOracle(pubKeyString))
        then throw("user is not oracle")
    else {
        WriteSet([
            DataEntry(getOracleIpsKey(pubKeyString), ips)
        ])
    }
}

# [called by price oracles]
@Callable(i)
func finalizeCurrentPrice(deficit: Int, prices: String, stringSigns: String) = {
    let msg = toBytes(formattingPriceMsg(deficit, prices, height))
    
    let signs = stringSigns.split(",")
    let validSignCount = 
        (if sigVerify(msg, fromBase58String(signs[0]), fromBase58String(pubKeyOraclesList[0])) then 1 else 0) +
        (if sigVerify(msg, fromBase58String(signs[1]), fromBase58String(pubKeyOraclesList[1])) then 1 else 0) +
        (if sigVerify(msg, fromBase58String(signs[2]), fromBase58String(pubKeyOraclesList[2])) then 1 else 0) +
        (if sigVerify(msg, fromBase58String(signs[3]), fromBase58String(pubKeyOraclesList[3])) then 1 else 0) +
        (if sigVerify(msg, fromBase58String(signs[4]), fromBase58String(pubKeyOraclesList[4])) then 1 else 0)


    if(isBlocked) 
        then throw("contract is blocked by EMERGENCY SHUTDOWN actions untill reactivation by emergency oracles") 
    else if(getPricesHistory(height) != 0) 
        then throw("wait next block") 
    else if (validSignCount < BftCoefficientOracle) 
        then throw("")
    else {
        let newIndex = providingIndex + 1
        WriteSet([
            DataEntry(ProvidingIndexKey, newIndex),
            DataEntry(getHeightByProvidingIndexKey(newIndex), height),

            DataEntry(PricesKey, prices),
            DataEntry(getPricesHistoryKey(height), prices),
            
            DataEntry(DeficitKey, deficit),
            DataEntry(getDeficitsHistoryKey(height), deficit)
        ])
    }
}

@Verifier(tx)
func verify() = {
    let pubKeyAdminsList = [
        "BLEoguzPVKVTfXxxT3W7Rqf8aUm2ggC9Vemd2MQawM2G",
        "FWVffYr2ALmHMejZm3WqeLz6Sdym3gLFGtJn4KTwyU5x",
        "3Wh2LaWcb5gg7K2pPcW3Ep6EAuRBzYkAgrdpt43jTDFa",
        "5WRXFSjwcTbNfKcJs8ZqXmSSWYsSVJUtMvMqZj5hH4Nc"
    ]
    let count =
        (if(sigVerify(tx.bodyBytes, tx.proofs[0], fromBase58String(pubKeyAdminsList[0]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[1], fromBase58String(pubKeyAdminsList[1]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[2], fromBase58String(pubKeyAdminsList[2]))) then 1 else 0) +
        (if(sigVerify(tx.bodyBytes, tx.proofs[3], fromBase58String(pubKeyAdminsList[3]))) then 2 else 0)

    count >= 3
}
